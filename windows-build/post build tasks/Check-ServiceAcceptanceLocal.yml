---
# Created by Michael Barron 27/03/2019
# Modified by Michael Barron 05/04/2019
# Service Acceptance check that runs on the Target Server

- hosts: all
  tasks:

# Create an Array to store results
  - name: Create Results Array
    set_fact: Service_Acceptance_Results="[ 'Service Acceptance Results' ]"

  - name: Check Backup Network Adapter exists
    win_shell: |
      Get-NetAdapter -Name "Backup" –ErrorAction SilentlyContinue
    register: backup_check
    ignore_errors: yes
    check_mode: no

  - name: Register backup_required true if backup NIC exists
    set_fact:
      backup_required: true
    when: backup_check.rc == 0

  - name: Register backup_required false if backup NIC doesnt exists
    set_fact:
      backup_required: false
    when: backup_check.rc != 0

  # Work out short domain name from full doamin name and store as fact
  - name: Define short name for EXPERIANUK
    set_fact:
      short_domain: EXPERIANUK
    when: ansible_windows_domain == 'uk.experian.local'

  - name: Define short name for GDC
    set_fact:
      short_domain: GDC
    when: ansible_windows_domain == 'gdc.local'

  - name: Define short name for IPANI
    set_fact:
      short_domain: IPANIUK
    when: ansible_windows_domain == 'ipani.uk.experian.com'

# Work out Admin and RDP Group names from hostname and store as fact
  - name: Define Admin Group Name
    set_fact:
      admin_account: "WS-ADM_{{ ansible_hostname }}"
  
  - name: Define RDP Group Name
    set_fact:
      rdp_account: "WS-STD_{{ ansible_hostname }}"

# Local access groups exist created by Configure Local Group Access role Admin
  - name: Check local Admin Group membership
    win_group_membership:
      name: Administrators
      members:
        - "{{ short_domain }}\\{{ admin_account }}"
      state: present
    register: local_admin_group

# Local access groups exist created by Configure Local Group Access role RDP
  - name: Check local RDP Group membership
    win_group_membership:
      name: Remote Desktop Users
      members:
        - "{{ short_domain }}\\{{ rdp_account }}"
      state: present
    register: local_rdp_group

# Check if the Check local Admin Group membership changed anything
  - name: Check if the Check local Admin Group membership changed anything
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Local Admin Group Exists = Failed' ]"
    when: local_admin_group.changed == true

  - name: Admin account exists
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Local Admin Group Exists = Passed' ]"
    when: local_admin_group.changed == false

# Check if the Check local Admin Group membership changed anything
  - name: Check if the Check local RDP Group membership changed anything
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Local RDP Group Exists = Failed' ]"
    when: local_rdp_group.changed == true

  - name: RDP Account Exists
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Local RDP Group Exists = Passed' ]"
    when: local_rdp_group.changed == false

# CHeck Primary Network Adapter Exists
  - name: Check Primary Network Adapter exists
    win_shell: |
      Get-NetAdapter -Name "Primary" –ErrorAction SilentlyContinue
    register: primary_nic
    ignore_errors: yes
    check_mode: no

  - name: Pass if Primary Network Adapter found
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Primary Adapter Exists = Passed' ]"
    when: primary_nic.rc == 0

  - name: Fail if no Primary Network Adapter found
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Primary Adapter Exists = Failed' ]"
    when: primary_nic.rc != 0

# Backup Required Block
  - name: Block for executing command only when backup required
    block:

    - name: Check Backup Network Adapter exists
      win_shell: |
        Get-NetAdapter -Name "Backup" –ErrorAction SilentlyContinue
      register: backup_nic
      ignore_errors: yes
      check_mode: no

    - name: Pass if Backup Network Adapter found
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Backup Adapter Exists = Passed' ]"
      when: backup_nic.rc == 0

    - name: Fail if no Backup Network Adapter found
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Backup Adapter Exists = Failed' ]"
      when: backup_nic.rc != 0

# Backup Required Block end
    when: 
      - backup_required

# Check that CCAdmin Account exists and is a member of Administrators
  - name: Check that CCAdmin Account exists and is a member of Administrators
    win_group_membership:
      name: Administrators
      members:
        - "CCAdmin"
      state: present
    register: CCAdmin_user

# Check if the Check local Admin Group membership changed anything
  - name: Check if the Check CCAdmin changed is false
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'CCAdmin Account Exists = Passed' ]"
    when: CCAdmin_user.changed == false

# Check if the Check local Admin Group membership changed anything
  - name: Check if the Check CCAdmin changed is true
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'CCAdmin Account Exists = Failed' ]"
    when: CCAdmin_user.changed == true

# Check that the Arcsight Account is a member of the event log readers group
  - name: Ensure user Arcsight is present EXPERIANUK Domain
    win_group_membership:
      name: Event Log Readers
      members:
        - "{{ short_domain }}\\arcsight"
      state: present
    register: arcsight_user
    when: "'uk.experian.local' in ansible_domain"

  - name: Ensure user ArcSvc is present GDC.LOCAL Domain
    win_group_membership:
      name: Event Log Readers
      members:
        - "{{ short_domain }}\\arcsvc"
      state: present
    register: arcsight_user
    when: "'gdc' in ansible_domain"

  - name: Ensure user Arcsight is present IPANI.UK.EXPERIAN.COM Domain
    win_group_membership:
      name: Event Log Readers
      members:
        - "{{ short_domain }}\\arcsight"
      state: present
    register: arcsight_user
    when: "'ipani' in ansible_domain"

# Check if the Check Arcsight changed anything
  - name: Check if the Check Arcsight changed true
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Arcsight Account Exists = Failed' ]"
    when: arcsight_user.changed == true

  - name: Check if the Check Arcsight changed false
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Arcsight Account Exists = Passed' ]"
    when: arcsight_user.changed == false

# Check that SS000DA exists and is in administrators group.
  - name: Check that SS000DA Account exists and is a member of Administrators
    win_group_membership:
      name: Administrators
      members:
        - "ss000da"
      state: present
    register: ss000da_user

# Check if the Check SS000DA changed anything
  - name: Check if the Check SS000DA changed true
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SS000DA Account Exists = Failed' ]"
    when: ss000da_user.changed == true

  - name: Check if the Check SS000DA changed false
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SS000DA Account Exists = Passed' ]"
    when: ss000da_user.changed == false

# GDC Block
  - name: Block for executing when GDC
    block:

# Check that sndlgdc exists and is in administrators group.
    - name: Check that sndlgdc Account exists and is a member of Administrators GDC
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\sndlgdc"
        state: present
      register: sndlgdc_user

# Check if the Check sndlgdc changed anything
    - name: Check if the Check sndlgdc changed true
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'sndlgdc Account Exists = Failed' ]"
      when: sndlgdc_user.changed == true

    - name: Check if the Check sndlgdc changed false
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'sndlgdc Account Exists = Passed' ]"
      when: sndlgdc_user.changed == false

# Check that ADMIN EGOC Operations exists and is in administrators group.
    - name: Check that ADMIN EGOC Operations Account exists and is a member of Administrators GDC
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\ADMIN EGOC Operations"
        state: present
      register: EGOC_OP_user

# Check if the Check ADMIN EGOC Operations changed anything
    - name: Check if the Check ADMIN EGOC Operations changed true
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ADMIN EGOC Operations Account Exists = Failed' ]"
      when: EGOC_OP_user.changed == true

    - name: Check if the Check ADMIN EGOC Operations changed true
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ADMIN EGOC Operations Account Exists = Passed' ]"
      when: EGOC_OP_user.changed == false

# Check that ADMIN DSG Engineers exists and is in administrators group.
    - name: Check that ADMIN DSG Engineers Account exists and is a member of Administrators GDC
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\ADMIN DSG Engineers"
        state: present
      register: admin_dsg_user

# Check if the Check ADMIN DSG Engineers changed anything
    - name: Check if the Check ADMIN DSG Engineers changed true
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ADMIN DSG Engineers Account Exists = Failed' ]"
      when: admin_dsg_user.changed == true

    - name: Check if the Check ADMIN DSG Engineers changed false
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ADMIN DSG Engineers Account Exists = Passed' ]"
      when: admin_dsg_user.changed == false

# GDC Block End
    when:
      - ansible_windows_domain == 'gdc.local'

# IPANIUK Block
  - name: Block for executing when IPANIUK
    block:

# Check that sndipaniuk exists and is in administrators group.
    - name: Check that sndipaniuk Account exists and is a member of Administrators IPANIUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\sndipaniuk"
        state: present
      register: sndipaniuk_user

# Check if the Check sndipaniuk changed anything
    - name: Check if the Check sndipaniuk changed true
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'sndipaniuk Account Exists = Failed' ]"
      when: sndipaniuk_user.changed == true

    - name: Check if the Check sndipaniuk changed false
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'sndipaniuk Account Exists = Passed' ]"
      when: sndipaniuk_user.changed == false

# Check that Domain Admins Account exists and is a member of Administrators IPANIUK
    - name: Check that Domain Admins Account exists and is a member of Administrators IPANIUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\Domain Admins"
        state: present
      register: domain_admin_user

# Check if the Check Domain Admins changed anything
    - name: Check if the Check Domain Admins changed true
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Domain Admins Account Exists = Failed' ]"
      when: domain_admin_user.changed == true

    - name: Check if the Check Domain Admins changed false
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Domain Admins Account Exists = Passed' ]"
      when: domain_admin_user.changed == false

# Check that ts command centre all users exists and is in administrators group.
    - name: Check that ts command centre all users Account exists and is a member of Administrators IPANIUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\ts command centre all users"
        state: present
      register: command_user

# Check if the Check ts command centre all users changed anything
    - name: Check if the Check ts command centre all users true anything
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ts command centre all users Account Exists = Failed' ]"
      when: command_user.changed == true

    - name: Check if the Check ts command centre all users false anything
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ts command centre all users Account Exists = Passed' ]"
      when: command_user.changed == false

# Check that ts-t-hs-serverops exists and is in administrators group.
    - name: Check that ts-t-hs-serverops Account exists and is a member of Administrators IPANIUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\ts-t-hs-serverops"
        state: present
      register: ts_t_user

# Check if the Check ts-t-hs-serverops changed anything
    - name: Check if the Check ts-t-hs-serverops changed true IPANIUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ts-t-hs-serverops Account Exists = Failed' ]"
      when: ts_t_user.changed == true

    - name: Check if the Check ts-t-hs-serverops changed false IPANIUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ts-t-hs-serverops Account Exists = Passed' ]"
      when: ts_t_user.changed == false

# IPANIUK Block End
    when:
      - ansible_windows_domain == 'ipani.uk.experian.com'

# EXPERIANUK Block
  - name: Block for executing when EXPERIANUK
    block:

# Check that snduk exists and is in administrators group.
    - name: Check that snduk Account exists and is a member of Administrators EXPERIANUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\snduk"
        state: present
      register: snduk_user

# Check if the Check snduk changed anything
    - name: Check if the Check snduk changed true
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'snduk Account Exists = Failed' ]"
      when: snduk_user.changed == true

    - name: Check if the Check snduk changed false
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'snduk Account Exists = Passed' ]"
      when: snduk_user.changed == false

# Check that ts command centre all users exists and is in administrators group.
    - name: Check that ts command centre all users Account exists and is a member of Administrators EXPERIANUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\ts command centre all users"
        state: present
      register: command_user

# Check if the Check ts command centre all users changed anything
    - name: Check if the Check ts command centre all users changed true
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ts command centre all users Account Exists = Failed' ]"
      when: command_user.changed == true

    - name: Check if the Check ts command centre all users changed false
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ts command centre all users Account Exists = Passed' ]"
      when: command_user.changed == false

# Check that ts-t-hs-serverops exists and is in administrators group.
    - name: Check that ts-t-hs-serverops Account exists and is a member of Administrators EXPERIANUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\ts-t-hs-serverops"
        state: present
      register: ts_t_user

# Check if the Check ts-t-hs-serverops changed anything
    - name: Check if the Check ts-t-hs-serverops changed true
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ts-t-hs-serverops Account Exists = Failed' ]"
      when: ts_t_user.changed == true

    - name: Check if the Check ts-t-hs-serverops changed false
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ts-t-hs-serverops Account Exists = Passed' ]"
      when: ts_t_user.changed == false

# Check that tdmukuser exists and is in administrators group.
    - name: Check that tdmukuser Account exists and is a member of Administrators EXPERIANUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\tdmukuser"
        state: present
      register: tdmukuser_user

# Check if the Check tdmukuser changed anything
    - name: Check if the Check tdmukuser changed true EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'tdmukuser Account Exists = Failed' ]"
      when: tdmukuser_user.changed == true

    - name: Check if the Check tdmukuser changed false EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'tdmukuser Account Exists = Passed' ]"
      when: tdmukuser_user.changed == false

# EXPERIANUK Block End
    when:
      - ansible_windows_domain == 'uk.experian.local'

# Check that Domain Admins has been removed from local administrators GDC and EXPRIANUK Only

# EXPERIANUK Block
#  - name: Block for executing when EXPERIANUK
#    block:

# Check that Domain Admins doesnt exists in administrators
#    - name: Check that Domain Admins Account doesnt exists in Administrators EXPERIANUK
#      win_group_membership:
#        name: Administrators
#        members:
#          - "{{ short_domain }}\\Domain Admins"
#        state: absent
#      register: Domain_Admins_user

# Check if the Check Domain Admins changed anything
#    - name: Check if the Check Domain Admins changed true EXPERINAUK
#      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Domain Admins Account Doesnt Exists = Failed' ]"
#      when: Domain_Admins_user.changed == true

#    - name: Check if the Check Domain Admins changed false EXPERINAUK
#      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Domain Admins Account Doesnt Exists = Passed' ]"
#      when: Domain_Admins_user.changed == false

# EXPERIANUK Block End
#    when:
#      - ansible_windows_domain == 'uk.experian.local'

# GDC Block
  - name: Block for executing when GDC or EXPERIANUK
    block:

# Check that Domain_Admins doesnt exists in administrators
    - name: Check that Domain Admins Account doesnt exists in Administrators GDC or EXPERIANUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\Domain Admins"
        state: absent
      register: Domain_Admins_user

# Check if the Check Domain Admins changed anything
    - name: Check if the Check Domain Admins changed true GDC or EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Domain Admins Account Doesnt Exists = Failed' ]"
      when: Domain_Admins_user.changed == true

    - name: Check if the Check Domain Admins changed false GDC or EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Domain Admins Account Doesnt Exists = Passed' ]"
      when: Domain_Admins_user.changed == false

# GDC Block End
    when: ansible_windows_domain == 'gdc.local' or ansible_windows_domain == 'uk.experian.local'

#Check that various groups/users have been removed from local administrators in case server was created in the computers container EXPERIANUK Only

# EXPERIANUK Block
  - name: Block for executing when EXPERIANUK
    block:

# Check that ADMIN Workstation Administration doesnt exists in administrators
    - name: Check that ADMIN Workstation Administration Account doesnt exists in Administrators EXPERIANUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\ADMIN Workstation Administration"
        state: absent
      register: Admin_ws_user

# Check if the Check ADMIN Workstation Administration changed anything
    - name: Check if the Check ADMIN Workstation Administration changed ture EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ADMIN Workstation Administration Account Doesnt Exists = Failed' ]"
      when: Admin_ws_user.changed == true

    - name: Check if the Check ADMIN Workstation Administration changed false EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ADMIN Workstation Administration Account Doesnt Exists = Passed' ]"
      when: Admin_ws_user.changed == false

# Check that CL-T-DskAdmin doesnt exists in administrators
    - name: Check that CL-T-DskAdmin Account doesnt exists in Administrators EXPERIANUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\CL-T-DskAdmin"
        state: absent
      register: DskAdmin_user

# Check if the Check CL-T-DskAdmin changed anything
    - name: Check if the Check CL-T-DskAdmin changed anything EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'CL-T-DskAdmin Account Doesnt Exists = Failed' ]"
      when: DskAdmin_user.changed == true

    - name: Check if the Check CL-T-DskAdmin changed anything EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'CL-T-DskAdmin Account Doesnt Exists = Passed' ]"
      when: DskAdmin_user.changed == false

# Check that Dept_BN_PCSupport doesnt exists in administrators
    - name: Check that Dept_BN_PCSupport Account doesnt exists in Administrators EXPERIANUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\Dept_BN_PCSupport"
        state: absent
      register: PCSupport_user

# Check if the Check Dept_BN_PCSupport changed anything
    - name: Check if the Check Dept_BN_PCSupport changed anything EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Dept_BN_PCSupport Account Doesnt Exists = Failed' ]"
      when: PCSupport_user.changed == true

    - name: Check if the Check Dept_BN_PCSupport changed anything EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Dept_BN_PCSupport Account Doesnt Exists = Passed' ]"
      when: PCSupport_user.changed == false

# Check that SSMgmtWKUKSvc doesnt exists in administrators
    - name: Check that SSMgmtWKUKSvc Account doesnt exists in Administrators EXPERIANUK
      win_group_membership:
        name: Administrators
        members:
          - "{{ short_domain }}\\SSMgmtWKUKSvc"
        state: absent
      register: SSMgmtWKUKSvc_user

# Check if the Check SSMgmtWKUKSvc changed anything
    - name: Check if the Check SSMgmtWKUKSvc changed true EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SSMgmtWKUKSvc Account Doesnt Exists = Failed' ]"
      when: SSMgmtWKUKSvc_user.changed == true

    - name: Check if the Check SSMgmtWKUKSvc changed false EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SSMgmtWKUKSvc Account Doesnt Exists = Passed' ]"
      when: SSMgmtWKUKSvc_user.changed == false

# EXPERIANUK Block End
    when:
      - ansible_windows_domain == 'uk.experian.local'

#Check that Telnet Client feature is installed
  - name: Check Telnet Client
    win_feature:
     name: "Telnet-Client"
     state: present
     restart: no
     include_sub_features: yes
     include_management_tools: yes
    register: telnet_results

  - name: Check if the Check Telnet Client changed true
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Telnet Client Installed = Failed' ]"
    when: telnet_results.changed == true

  - name: Check if the Check Telnet Client changed false
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Telnet Client Installed = Passed' ]"
    when: telnet_results.changed == false

#Check that SNMP Service is installed
  - name: Check SNMP Service
    win_feature:
     name: "SNMP-Service"
     state: present
     restart: no
     include_sub_features: yes
     include_management_tools: yes
    register: snmp_reults

  - name: Check if the Check SNMP Service changed true
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SNMP Service Installed = Failed' ]"
    when: snmp_reults.changed == true

  - name: Check if the Check SNMP Service changed false
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SNMP Service Installed = Passed' ]"
    when: snmp_reults.changed == false

#Check that Windows-Server-Backup feature is installed
  - name: Check Windows-Server-Backup
    win_feature:
     name: "Windows-Server-Backup"
     state: present
     restart: no
     include_sub_features: yes
     include_management_tools: yes
    register: win_backup_results

  - name: Check if the Check Windows-Server-Backup changed anything
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Server Backup Service Installed = Failed' ]"
    when: win_backup_results.changed == true

  - name: Check if the Check Windows-Server-Backup changed anything
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Server Backup Service Installed = Passed' ]"
    when: win_backup_results.changed == false

# Firewall Rule Checks
  - name: Check Remote Desktop Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'Remote Desktop').Enabled -eq 'True'
    register: rd_firewall_rules
    check_mode: no

  - name: Fail if Check Remote Desktop Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Desktop Firewall Group enabled = Failed' ]"
    when: rd_firewall_rules.rc != 0

  - name: Pass if Check Remote Desktop Firewall Rule group enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Desktop Firewall Group enabled = Passed' ]"
    when: rd_firewall_rules.rc == 0

# File and Printer Sharing

  - name: Check File and Printer Sharing Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'File and Printer Sharing').Enabled -eq 'True'
    register: fps_firewall_rules
    check_mode: no

  - name: Fail if Check File and Printer Sharing Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'File and Printer Sharing Firewall Group enabled = Failed' ]"
    when: fps_firewall_rules.rc != 0

  - name: Pass if Check File and Printer Sharing Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'File and Printer Sharing Firewall Group enabled = Passed' ]"
    when: fps_firewall_rules.rc == 0

# Remote Service Management

  - name: Check Remote Service Management Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'Remote Service Management').Enabled -eq 'True'
    register: rsm_firewall_rules
    check_mode: no

  - name: Fail if Check Remote Service Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Service Management Firewall Group enabled = Failed' ]"
    when: rsm_firewall_rules.rc != 0

  - name: Pass if Check Remote Service Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Service Management Firewall Group enabled = Passed' ]"
    when: rsm_firewall_rules.rc == 0

# Performance Logs and Alerts

  - name: Check Performance Logs and Alerts Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'Performance Logs and Alerts').Enabled -eq 'True'
    register: pla_firewall_rules
    check_mode: no

  - name: Fail if Check Performance Logs and Alerts Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Performance Logs and Alerts Firewall Group enabled = Failed' ]"
    when: pla_firewall_rules.rc != 0

  - name: Pass if Check Performance Logs and Alerts Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Performance Logs and Alerts Firewall Group enabled = Passed' ]"
    when: pla_firewall_rules.rc == 0

# Remote Event Log Management

  - name: Check Remote Event Log Management Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'Remote Event Log Management').Enabled -eq 'True'
    register: relm_firewall_rules
    check_mode: no

  - name: Fail if Check Remote Event Log Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Event Log Management Firewall Group enabled = Failed' ]"
    when: relm_firewall_rules.rc != 0

  - name: Pass if Check Remote Event Log Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Event Log Management Firewall Group enabled = Passed' ]"
    when: relm_firewall_rules.rc == 0

# Remote Scheduled Tasks Management

  - name: Check Remote Scheduled Tasks Management Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'Remote Scheduled Tasks Management').Enabled -eq 'True'
    register: rstm_firewall_rules
    check_mode: no

  - name: Fail if Check Remote Scheduled Tasks Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Scheduled Tasks Management Firewall Group enabled = Failed' ]"
    when: rstm_firewall_rules.rc != 0

  - name: Pass if Check Remote Scheduled Tasks Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Scheduled Tasks Management Firewall Group enabled = Passed' ]"
    when: rstm_firewall_rules.rc == 0

# Remote Volume Management

  - name: Check Remote Volume Management Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'Remote Volume Management').Enabled -eq 'True'
    register: rvm_firewall_rules
    check_mode: no

  - name: Fail if Check Remote Volume Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Volume Management Firewall Group enabled = Failed' ]"
    when: rvm_firewall_rules.rc != 0

  - name: Pass if Check Remote Volume Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Remote Volume Management Firewall Group enabled = Passed' ]"
    when: rvm_firewall_rules.rc == 0

# Windows Firewall Remote Management

  - name: Check Windows Firewall Remote Management Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'Windows Firewall Remote Management').Enabled -eq 'True'
    register: wfrm_firewall_rules
    check_mode: no

  - name: Fail if Check Windows Firewall Remote Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Firewall Remote Management Firewall Group enabled = Failed' ]"
    when: wfrm_firewall_rules.rc != 0

  - name: Pass if Check Windows Firewall Remote Management Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Firewall Remote Management Firewall Group enabled = Passed' ]"
    when: wfrm_firewall_rules.rc == 0

# windows management instrumentation (wmi)

  - name: Check windows management instrumentation (wmi) Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'windows management instrumentation (wmi)').Enabled -eq 'True'
    register: wmi_firewall_rules
    check_mode: no

  - name: Fail if Check windows management instrumentation (wmi) Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Management Instrumentation Firewall Group enabled = Failed' ]"
    when: wmi_firewall_rules.rc != 0

  - name: Pass if Check windows management instrumentation (wmi) Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Management Instrumentation Firewall Group enabled = Passed' ]"
    when: wmi_firewall_rules.rc == 0

# Com+ Network Access

  - name: Check Com+ Network Access Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'Com+ Network Access').Enabled -eq 'True'
    register: cna_firewall_rules
    check_mode: no

  - name: Fail if Check windows Com+ Network Access Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Com+ Network Access Firewall Group enabled = Failed' ]"
    when: cna_firewall_rules.rc != 0

  - name: Pass if Check windows Com+ Network Access Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Com+ Network Access Firewall Group enabled = Passed' ]"
    when: cna_firewall_rules.rc == 0

# Com+ Remote Administration

  - name: Check Com+ Remote Administration Firewall Rule group is enabled
    win_shell: |
      (get-netfirewallrule -displaygroup 'Com+ Remote Administration').Enabled -eq 'True'
    register: cra_firewall_rules
    check_mode: no

  - name: Fail if Check windows Com+ Remote Administration Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Com+ Remote Administration Firewall Group enabled = Failed' ]"
    when: cra_firewall_rules.rc != 0

  - name: Pass if Check windows Com+ Remote Administration Firewall Rule group not enabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Windows Com+ Remote Administration Firewall Group enabled = Passed' ]"
    when: cra_firewall_rules.rc == 0

# Block for UAC LocalAccountTokenFilterPolicy registry if server is 2012
  - name: Block for executing command only when Windows Server 2012
    block:

# Gather for UAC LocalAccountTokenFilterPolicy version key value
    - name: Gather UAC LocalAccountTokenFilterPolicy registry version from Registry
      win_reg_stat:
        path: HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\policies\system\
        name: LocalAccountTokenFilterPolicy
      register: uac_results
    
    - name: Pass if UAC LocalAccountTokenFilterPolicy registry is installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'UAC LocalAccountTokenFilterPolicy registry setting = Passed' ]"
      when:
        - uac_results.value == 1
        - uac_results is defined

    - name: Fail if UAC LocalAccountTokenFilterPolicy registry is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'UAC LocalAccountTokenFilterPolicy registry setting = Failed' ]"
      when: uac_results is undefined or uac_results.value == 0

# UAC LocalAccountTokenFilterPolicy Block End
    when:
      - "'2012' in ansible_os_name"

# Check ReceiveSideScaling setting
  - name: Check ReceiveSideScaling is enabled
    win_shell: |
      (Get-NetOffloadGlobalSetting).ReceiveSideScaling -eq 'Enabled'
    register: rss_results
    check_mode: no

  - name: debug rss_results
    debug:
      var: rss_results

# Block to check ReceiveSideScaling is disabled if server is 2012
  - name: Block for executing command only when Windows Server 2012
    block:

    - name: Fail if ReceiveSideScaling setting is enabled 2012
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ReceiveSideScaling setting Disabled Check = Passed' ]"
      when: "'False' in rss_results.stdout"

    - name: Pass if ReceiveSideScaling setting is disabled 2012
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ReceiveSideScaling setting Disabled Check = Failed' ]"
      when: "'True' in rss_results.stdout"

# ReceiveSideScaling 2012 Block End
    when:
      - "'2012' in ansible_os_name"

# Check ReceiveSideScaling registry is enabled if server is 2016
  - name: Block for executing command only when Windows Server 2016
    block:

    - name: Pass if ReceiveSideScaling setting is enabled 2016
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ReceiveSideScaling setting Enabled Check = Passed' ]"
      when: "'True' in rss_results.stdout"

    - name: Fail if ReceiveSideScaling setting is disabled 2016
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ReceiveSideScaling setting Enabled Check = Failed' ]"
      when: "'False' in rss_results.stdout"

# ReceiveSideScaling 2016 Block End
    when:
      - "'2016' in ansible_os_name"

# Check that SS000DA account has a non-expiring password
  - name: Check that SS000DA account has a non-expiring password
    win_user:
      name: SS000DA
      state: query
    register: ss000da_results
    check_mode: no

# Check SS000DA account has an non-expiring password if server is 2012
  - name: Block for executing command only when Windows Server 2012
    block:

# Fail if SS000DA account has an expiring password
    - name: Fail if SS000DA account has a non-expiring password
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SS000DA account has a non-expiring password Check = Failed' ]"
      when: ss000da_results is undefined or ss000da_results.password_never_expires == false

# Debug if SS000DA account has an non-expiring password
    - name: Debug if SS000DA account has an non-expiring password
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SS000DA account has a non-expiring password Check = Passed' ]"
      when: 
        - ss000da_results is defined
        - ss000da_results.password_never_expires == true

# Check SS000DA account has an non-expiring password 2012 Block End
    when:
      - "'2012' in ansible_os_name"

# Check SS000DA account has an expiring password if server is 2016
  - name: Block for executing command only when Windows Server 2016
    block:

# Fail if SS000DA account has an expiring password 2016
    - name: Fail if SS000DA account has a non-expiring password
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SS000DA account has a non-expiring password Check = Failed' ]"
      when: ss000da_results is undefined or ss000da_results.password_never_expires == true

# Debug if SS000DA account has an non-expiring password 2016
    - name: Debug if SS000DA account has an expiring password
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SS000DA account has a non-expiring password Check = Passed' ]"
      when: 
        - ss000da_results is defined
        - ss000da_results.password_never_expires == false

# ReceiveSideScaling 2016 Block End
    when:
      - "'2016' in ansible_os_name"

# Check that experian key has been created
# Gather experian registry key value
  - name: Gather experian registry key value from Registry
    win_reg_stat:
      path: HKLM:\SOFTWARE\Experian\
      name: Build Description
    register: build_desc_results

# Block for Check that experian registry key if server is 2012 R2
  - name: Block for executing command only when Windows Server 2012 R2
    block:

    - name: Check that experian registry key for 2012 R2 exists
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Experian registry key for 2012 R2 build Check = Passed' ]"
      when:
        - build_desc_results.exists == true
        - "'Windows Server 2012 R2 Standard Hardened Build' in build_desc_results.value"

    - name: Fail if Fail if Experian registry key for 2012 R2 doesnt exist or is incorrect version
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Experian registry key for 2012 R2 build Check = Failed' ]"
      when: build_desc_results.exists == false or build_desc_results.value != 'Windows Server 2012 R2 Standard Hardened Build'

# Check that experian registry key Block End 2012 R2
    when:
      - "'2012 R2' in ansible_os_name"

# Block for Check that experian registry key if server is 2016
  - name: Block for executing command only when Windows Server 2016
    block:

    - name: Check that experian registry key for 2016 exists
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Experian registry key for 2016 build Check = Passed' ]"
      when:
        - build_desc_results.exists == true
        - "'Windows Server 2016 Hardened Build' in build_desc_results.value"

    - name: Fail if Experian registry key for 2016 doesnt exist or is incorrect version
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Experian registry key for 2016 build Check = Failed' ]"
      when: build_desc_results.exists == false or build_desc_results.value != 'Windows Server 2016 Hardened Build'

# Check that experian registry key Block End 2016
    when:
      - "'2016' in ansible_os_name"

# Check that no NICs have Link-Layer Topolgy Discovery Mapper I/O Driver, Link-Layer Topolgy Discovery Responder, QOS Packet Scheduler installed.

#Uninstall the following protocols / services:
#QOS Packet Scheduler
#Link-Layer Topology Mapper IO Driver
#Link-Layer Topology Mapper IO Responder
#MS LLDP Protocol Driver is new for server 2016
  - name: 
    win_shell: C:\Windows\System32\netcfg.exe -u ms_pacer
    register: ms_pacer_result
    check_mode: no

  - name: Fail if ms_pacer Protocol Driver is installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ms_pacer Protocol Driver is not installed Check = Failed' ]"
    when: "'is not installed' not in ms_pacer_result.stdout"

  - name: Pass if ms_pacer Protocol Driver is installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ms_pacer Protocol Driver is not installed Check = Passed' ]"
    when: "'is not installed' in ms_pacer_result.stdout"

  - name: 
    win_shell: C:\Windows\System32\netcfg.exe -u ms_lltdio
    register: ms_lltdio_result
    check_mode: no

  - name: Fail if ms_lltdio Protocol Driver is installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ms_lltdio Protocol Driver is not installed Check = Failed' ]"
    when: "'is not installed' not in ms_lltdio_result.stdout"

  - name: Pass if ms_lltdio Protocol Driver is not installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ms_lltdio Protocol Driver is not installed Check = Passed' ]"
    when: "'is not installed' in ms_lltdio_result.stdout"

  - name: 
    win_shell: C:\Windows\System32\netcfg.exe -u ms_rspndr
    register: ms_rspndr_result
    check_mode: no

  - name: Fail if ms_rspndr Protocol Driver is installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ms_rspndr Protocol Driver is not installed Check = Failed' ]"
    when: "'is not installed' not in ms_rspndr_result.stdout"

  - name: Pass if ms_rspndr Protocol Driver is not installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ms_rspndr Protocol Driver is not installed Check = Passed' ]"
    when: "'is not installed' in ms_rspndr_result.stdout"

# Block for Check that experian registry key if server is 2016
  - name: Block for executing command only when Windows Server 2016
    block:

# Check MS LLDP Protocol Driver is uninstalled 2016
    - name: Check MS LLDP Protocol Driver is uninstalled 2016
      win_shell: C:\Windows\System32\netcfg.exe -u ms_lldp
      register: ms_lldp_result
      check_mode: no

    - name: Fail if MS LLDP Protocol Driver is installed 2016
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'MS LLDP Protocol Driver is not installed Check = Failed' ]"
      when: "'is not installed' not in ms_lldp_result.stdout"

    - name: Pass if MS LLDP Protocol Driver is not installed 2016
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'MS LLDP Protocol Driver is not installed Check = Passed' ]"
      when: "'is not installed' in ms_lldp_result.stdout"

# Check that experian registry key Block End 2016
    when:
      - "'2016' in ansible_os_name"

# Check that IPv6 is disabled Primary
  - name: Check IPv6 Protocol is uninstalled Primary
    win_shell: |
      (Get-NetAdapterBinding -Name 'Primary' –ComponentID ms_tcpip6).Enabled
    register: ipv6_p_result
    check_mode: no

  - name: Fail if IPv6 Protocol is installed Primary
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'IPv6 Protocol is not installed Primary Check = Failed' ]"
    when: "'True' in ipv6_p_result.stdout"

  - name: Pass if IPv6 Protocol is installed Primary
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'IPv6 Protocol is not installed Primary Check = Passed' ]"
    when: "'False' in ipv6_p_result.stdout"

# Check that Backup protocols are disabled 
# Backup Required Block
  - name: Block for executing command only when backup required
    block:

    - name: Check IPv6 Protocol is uninstalled Backup
      win_shell: |
        (Get-NetAdapterBinding -Name 'Backup' –ComponentID ms_tcpip6).Enabled
      register: ipv6_bk_result
      check_mode: no

    - name: Fail if IPv6 Protocol is installed Backup
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'IPv6 Protocol is not installed Backup Check = Failed' ]"
      when: "'True' in ipv6_bk_result.stdout"

    - name: Pass if IPv6 Protocol is installed Backup
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'IPv6 Protocol is not installed Backup Check = Passed' ]"
      when: "'False' in ipv6_bk_result.stdout"

    - name: Check msclient Protocol is uninstalled Backup
      win_shell: |
        (Get-NetAdapterBinding -Name 'Backup' –ComponentID ms_msclient).Enabled
      register: msc_bk_result
      check_mode: no

    - name: Fail if msclient Protocol is installed Backup
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'msclient Protocol is not installed Backup Check = Failed' ]"
      when: "'True' in msc_bk_result.stdout"

    - name: Pass if msclient Protocol is not installed Backup
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'msclient Protocol is not installed Backup Check = Passed' ]"
      when: "'False' in msc_bk_result.stdout"

    - name: Check msserver Protocol is uninstalled Backup
      win_shell: |
        (Get-NetAdapterBinding -Name 'Backup' –ComponentID ms_server).Enabled
      register: mss_bk_result
      check_mode: no

    - name: Fail if msserver Protocol is installed Backup
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'msserver Protocol is not installed Backup Check = Failed' ]"
      when: "'True' in mss_bk_result.stdout"

    - name: Pass if msserver Protocol is not installed Backup
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'msserver Protocol is not installed Backup Check = Passed' ]"
      when: "'False' in mss_bk_result.stdout"

# Backup Required Block end
    when: 
      - backup_required

# Check ConnectionSpecificSuffix on Primary
# EXPERIANUK Block
  - name: Block for executing when EXPERIANUK
    block:

    - name: Check ConnectionSpecificSuffix on Primary Interface
      win_shell: |
        (Get-DNSClient –InterfaceAlias ‘Primary’).ConnectionSpecificSuffix
      register: css_p_result
      check_mode: no

    - name: Fail if Check ConnectionSpecificSuffix on Primary Interface
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ConnectionSpecificSuffix Check Primary = Failed' ]"
      when: "'uk.experian.local' not in css_p_result.stdout"

    - name: Pass if Check ConnectionSpecificSuffix on Primary Interface
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ConnectionSpecificSuffix Check Primary = Passed' ]"
      when: "'uk.experian.local' in css_p_result.stdout"

# EXPERIANUK Block End
    when:
      - ansible_windows_domain == 'uk.experian.local'

# GDC Block
  - name: Block for executing when EXPERIANUK
    block:

    - name: Check ConnectionSpecificSuffix on Primary Interface
      win_shell: |
        (Get-DNSClient –InterfaceAlias ‘Primary’).ConnectionSpecificSuffix
      register: css_p_result
      check_mode: no

    - name: Fail if Check ConnectionSpecificSuffix on Primary Interface
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ConnectionSpecificSuffix Check Primary = Failed' ]"
      when: "'gdc.local' not in css_p_result.stdout"

    - name: Pass if Check ConnectionSpecificSuffix on Primary Interface
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ConnectionSpecificSuffix Check Primary = Passed' ]"
      when: "'gdc.local' in css_p_result.stdout"

# GDC Block End
    when:
      - ansible_windows_domain == 'gdc.local'

# IPANIUK Block
  - name: Block for executing when EXPERIANUK
    block:

    - name: Check ConnectionSpecificSuffix on Primary Interface
      win_shell: |
        (Get-DNSClient –InterfaceAlias ‘Primary’).ConnectionSpecificSuffix
      register: css_p_result
      check_mode: no

    - name: Fail if Check ConnectionSpecificSuffix on Primary Interface
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ConnectionSpecificSuffix Check Primary = Failed' ]"
      when: "'ipani.uk.experian.com' not in css_p_result.stdout"

    - name: Pass if Check ConnectionSpecificSuffix on Primary Interface
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'ConnectionSpecificSuffix Check Primary = Passed' ]"
      when: "'ipani.uk.experian.com' in css_p_result.stdout"

# IPANIUK Block End
    when:
      - ansible_windows_domain == 'ipani.uk.experian.com'

# Check that NETBIOS is disabled
  - name: Check NETBIOS Protocol is disabled
    win_shell: |
      (Get-WmiObject win32_networkadapterconfiguration).TcpipNetbiosOptions
    register: netbios_result
    check_mode: no

  - name: Fail when NETBIOS is not disabled Primary
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'NETBIOS is disabled Check Primary = Failed' ]"
    when: "'2' not in netbios_result.stdout_lines[0]"

  - name: Pass when NETBIOS is disabled Primary
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'NETBIOS is disabled Check Primary = Passed' ]"
    when: "'2' in netbios_result.stdout_lines[0]"

# Backup Required Block
  - name: Block for executing command only when backup
    block:

    - name: Fail when NETBIOS is not disabled Backup
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'NETBIOS is disabled Check Backup = Failed' ]"
      when: "'2' not in netbios_result.stdout_lines[1]"

    - name: Pass when NETBIOS is disabled Backup
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'NETBIOS is disabled Check Backup = Passed' ]"
      when: "'2' in netbios_result.stdout_lines[1]"

# Backup Required Block end
    when: 
      - backup_required

# Check that LMHosts is disabled
  - name: Check LMHosts Protocol is disabled
    win_shell: |
      (Get-WmiObject win32_networkadapterconfiguration).WINSEnableLMHostsLookup
    register: lmhosts_result
    check_mode: no

  - name: Fail when LMHosts is not disabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'LMHosts is disabled Check = Failed' ]"
    when: "'True' in lmhosts_result.stdout"

  - name: Pass when LMHosts is disabled
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'LMHosts is disabled Check = Passed' ]"
    when: "'False' in lmhosts_result.stdout"

# Backup Interface has DNS Registration disabled
  - name: Check DNS Registration is disabled Backup
    win_shell: |
      (Get-DNSClient –InterfaceAlias ‘Backup’).RegisterThisConnectionsAddress
    register: dnsr_result
    check_mode: no

  - name: Fail when DNS Registration is not disabled Backup
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Backup Interface has DNS Registration disabled Check = Failed' ]"
    when: "'True' in dnsr_result.stdout"

  - name: Pass when DNS Registration is disabled Backup
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Backup Interface has DNS Registration disabled Check = Passed' ]"
    when: "'False' in dnsr_result.stdout"

# Check that Interface does not have a DNS Server registered Backup
  - name: Check that Interface does not have a DNS Server registered Backup
    win_shell: |
      (Get-DNSClientServerAddress –InterfaceAlias ‘Backup’ -AddressFamily IPv4).ServerAddresses
    register: dnss_result
    check_mode: no

  - name: Fail Interface has a DNS Server registered Backup
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Backup Interface Doesnt has a DNS Server registered Check = Failed' ]"
    when: dnss_result.stdout != ""

  - name: Pass Interface doesnt have a DNS Server registered Backup
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Backup Interface Doesnt has a DNS Server registered Check = Passed' ]"
    when: dnss_result.stdout == ""

# Block for Check IPv4 Binding Order. Check that primary is first if server is 2012
  - name: Block for executing command only when Windows Server 2012
    block:

# Copy nvspbind to server C:\tmp

    - name: copy nvspbind to server
      win_copy:
        src: "{{ sourcePath }}{{ nvspbind }}"
        dest: C:\temp\
      check_mode: no

# Check IPv4 Binding Order. Check that primary is first

    - name: Check IPv4 Binding Order. Check that primary is first
      win_command: C:\temp\nvspbind.exe /o ms_tcpip
      args:
        chdir: C:\temp\
      register: ipv4bind_results
      check_mode: no

    - name: Fail on incorrect IPv4 Binding Order
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'IPv4 Binding Order Check = Failed' ]"
      when:  "'   enabled:   Primary' not in ipv4bind_results.stdout_lines[10]"

    - name: Pass on correct IPv4 Binding Order
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'IPv4 Binding Order Check = Passed' ]"
      when:  "'   enabled:   Primary' in ipv4bind_results.stdout_lines[10]"

    - name: remove nvpbind
      win_file:
        path: C:\temp\{{ nvspbind }}
        state: absent
      check_mode: no

# Block End
    when:
      - "'2012' in ansible_os_name"

# Check that DNS Servers are correct

# GDC Block
  - name: Block for executing when GDC
    block:

    - name: Check that DNS Servers are correct
      win_shell: | 
        (Get-DNSClientServerAddress -InterfaceAlias "Primary" -AddressFamily IPv4).ServerAddresses
      register: dnss_results
      check_mode: no

    - name: Fail on incorrect DNS Servers GDC
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'DNS Servers Check = Failed' ]"
      when:
        - "'10.188.21.1' not in dnss_results.stdout_lines[0]"
        - "'10.188.21.2' not in dnss_results.stdout_lines[1]"

    - name: Pass on correct DNS Servers GDC
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'DNS Servers Check = Passed' ]"
      when:
        - "'10.188.21.1' in dnss_results.stdout_lines[0]"
        - "'10.188.21.2' in dnss_results.stdout_lines[1]"

# GDC Block End
    when:
      - ansible_windows_domain == 'gdc.local'

# IPANIUK Block
  - name: Block for executing when IPANIUK
    block:

    - name: Check that DNS Servers are correct
      win_shell: | 
        (Get-DNSClientServerAddress -InterfaceAlias "Primary" -AddressFamily IPv4).ServerAddresses
      register: dnss_results
      check_mode: no

    - name: Fail on incorrect DNS Servers IPANIUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'DNS Servers Check = Failed' ]"
      when:  
        - "'194.60.173.145' not in dnss_results.stdout_lines[0]"
        - "'194.60.173.146' not in dnss_results.stdout_lines[1]"

    - name: Pass on correct DNS Servers IPANIUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'DNS Servers Check = Passed' ]"
      when:  
        - "'194.60.173.145' in dnss_results.stdout_lines[0]"
        - "'194.60.173.146' in dnss_results.stdout_lines[1]"

# IPANIUK Block End
    when:
      - ansible_windows_domain == 'ipani.uk.experian.com'

# EXPERIANUK Block
  - name: Block for executing when EXPERIANUK
    block:

    - name: Check that DNS Servers are correct
      win_shell: | 
        (Get-DNSClientServerAddress -InterfaceAlias "Primary" -AddressFamily IPv4).ServerAddresses
      register: dnss_results
      check_mode: no

    - name: Fail on incorrect DNS Servers EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'DNS Servers Check = Failed' ]"
      when:  
        - "'10.215.252.10' not in dnss_results.stdout_lines[0]"
        - "'10.173.251.106' not in dnss_results.stdout_lines[1]"

    - name: Pass on correct DNS Servers EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'DNS Servers Check = Passed' ]"
      when:  
        - "'10.215.252.10' in dnss_results.stdout_lines[0]"
        - "'10.173.251.106' in dnss_results.stdout_lines[1]"

# EXPERIANUK Block End
    when:
      - ansible_windows_domain == 'uk.experian.local'

# EXPERIANUK Block
  - name: Block for executing when EXPERIANUK
    block:

    - name: 
      win_shell: |
        (Get-WmiObject win32_networkadapterconfiguration).WINSPrimaryServer
      register: wins_p_results
      check_mode: no

    - name: 
      win_shell: |
        (Get-WmiObject win32_networkadapterconfiguration).WINSSecondaryServer
      register: wins_s_results
      check_mode: no

    - name: Fail on incorrect WINS Servers EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'WINS Servers Check = Failed' ]"
      when:
        - wins_p_results.stdout_lines[0] != "10.215.252.12"
        - wins_s_results.stdout_lines[0] != "10.173.243.146"

    - name: Pass on correct DNS Servers EXPERIANUK
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'WINS Servers Check = Passed' ]"
      when:
        - wins_p_results.stdout_lines[0] == "10.215.252.12"
        - wins_s_results.stdout_lines[0] == "10.173.243.146"

    when:
      - ansible_windows_domain == 'uk.experian.local'

#Check C Volume Label, use win_disk_info?
########################################################################################################
  - name: 
    win_shell: |
      (Get-Volume -Driveletter 'C').FileSystemLabel -eq 'System'
    register: drivec_results
    check_mode: no

  - name: Fail when C drive label is not System
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'C drive label is System Check = Failed' ]"
    when: "'False' in drivec_results.stdout"

  - name: Pass when C drive label is System
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'C drive label is System Check = Passed' ]"
    when: "'True' in drivec_results.stdout"

#Check Disk 1 is MBR for 2012/2012R2 and all disks GPT for 2016
#######################################################################################################

  # Drive Check Loop
  - name: Check to loop through all drives looking for D
    win_disk_facts:

  - name: debug win_disk_facts
    debug:
      var: ansible_facts.disks
  
  - name: "with_subelements and loop example of disk check"
    debug:
      var: disk.0.drive_letter
    with_subelements:
      - "{{ ansible_disks }}"
      - partitions
      - flags:
        skip_missing: true
    loop_control:
      loop_var: disk
    register: disk_results
    when:
      - disk.1.drive_letter
      - "'C' in disk.1.drive_letter"

# Block for Check Disk 1 is MBR if server is 2012
  - name: Block for executing command only when Windows Server 2012
    block:

    - name: Output first disk
      debug:
        var: disk_results

# Block End
    when:
      - "'2012' in ansible_os_name"

# Block for Check all disks GPT if server is 2016
  - name: Block for executing command only when Windows Server 2016
    block:

    - name: Output first disk
      debug:
        var: disk_results

# Block End
    when:
      - "'2016' in ansible_os_name"

#######################################################################################################

# Check Disk 1 Driveletter
  - name: Check Disk 1 Drive Letter
    win_shell: |
      (Get-Partition -DiskNumber 1).DriveLetter
    register: drive_letter_result
    check_mode: no

  - name: Debug drive_letter_result
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Disk 1 Drive Letter is Y Check = Passed' ]"
    when: "'Y' in drive_letter_result.stdout_lines"

  - name: Fail if Disk 1 Drive Letter is not Y
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Disk 1 Drive Letter is Y Check = Failed' ]"
    when: "'Y' not in drive_letter_result.stdout_lines"

# Block for Check Y Volume Label if server is 2012
  - name: Block for executing command only when Windows Server 2012
    block:

    - name: Check Y drive Label 2012
      win_shell: |
        (Get-Volume -Driveletter 'Y').FileSystemLabel -eq 'GTS-Support-Only'
      register: drivey_results
      check_mode: no

    - name: Fail when Y drive label is not GTS-Support-Only 2012
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Y drive label is GTS-Support-Only Check = Failed' ]"
      when: "'False' in drivey_results.stdout"

    - name: Pass when Y drive label is not GTS-Support-Only 2012
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Y drive label is GTS-Support-Only Check = Passed' ]"
      when: "'True' in drivey_results.stdout"

# Block End
    when:
      - "'2012' in ansible_os_name"

# Block for Check Y Volume Label if server is 2016
  - name: Block for executing command only when Windows Server 2016
    block:

    - name: Check Y drive Label 2016
      win_shell: |
        (Get-Volume -Driveletter 'Y').FileSystemLabel -eq 'EITS-Support-Only'
      register: drivey_results
      check_mode: no

    - name: Fail when Y drive label is not EITS-Support-Only 2016
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Y drive label is EITS-Support-Only Check = Failed' ]"
      when: "'False' in drivey_results.stdout"

    - name: Pass when Y drive label is EITS-Support-Only 2016
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Y drive label is EITS-Support-Only Check = Passed' ]"
      when: "'True' in drivey_results.stdout"

# Block End
    when:
      - "'2016' in ansible_os_name"

# Check CDROM is Driveletter Z
  - name: Check CD-Rom drive letter
    win_shell: |
      (gwmi win32_cdromdrive).Drive 
    register: cd_result
    check_mode: no

  - name: Fail when CD-Rom drive letter is not Z
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'CD-Rom drive Z Check = Failed' ]"
    when: "'Z' not in cd_result.stdout"

  - name: Pass when CD-Rom drive letter is Z
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'CD-Rom drive Z Check = Passed' ]"
    when: "'Z' in cd_result.stdout"

######################## Check for existence and versions of following software and test if running if applicable ################
# SAFE - (get-Service -DisplayName "Enstart64").Status -eq "Running"
# BladeLogic - (get-Service -DisplayName "BMC BladeLogic Server Automation RSCD Agent").Status
# FireEye - (get-Service -DisplayName "FireEye Endpoint Agent").Status -eq "Running"
# NetBackup - (get-Service -DisplayName "NetBackup Client Service").Status -eq "Running"
# VMWare Tools - (get-Service -DisplayName "VMware Tools").Status -eq "Running"
# McAfee Framework - (get-Service -DisplayName "McAfee Agent Service").Status -eq "Running"
# McAfee Endpoint Security Platform - Done
# Tanium - (get-Service -DisplayName "Tanium Client").Status -eq "Running"
# .NET Framework - Done
# Powershell - Done
# Splunk Universal Forwarder - (get-Service -DisplayName "SplunkForwarder Service").Status -eq "Running"
# Qualys Agent - (get-Service -DisplayName "Qualys Cloud Agent").Status -eq "Running"
# Dynatrace - WIP - (get-Service -DisplayName "Dynatrace").Status -eq "Running"

#SAFE
  - name: Check SAFE Servlet Installed Version
    win_reg_stat:
      path: HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{E39C38FC-343C-4D3D-8DCA-681C7FF8518A}
      name: DisplayVersion
    register: safe_result

# Block Start
  - name: Block for executing command only when safe_result exists
    block:

    - name: Pass SAFE Servlet Version Check
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SAFE Servlet Check = Passed' ]"
      when: safe_result.value == safe_version

    - name: Fail if SAFE Servlet is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SAFE Servlet Check = Failed' ]"
      when: safe_result.value != safe_version

# Block End
    when:  safe_result.exists == true

# Block Start
  - name: Block for executing command only when safe_result doesnt exists
    block:

    - name: Fail if SAFE Servlet is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'SAFE Servlet Check = Failed' ]"

# Block End
    when: safe_result.exists == false

#BladeLogic
  - name: Check BladeLogic Installed Version
    win_reg_stat:
      path: HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\{0370E432-D0E3-48B9-AA55-3FC347248361}
      name: DisplayVersion
    register: bl_result

# Block Start
  - name: Block for executing command only when bl_result exists
    block:

    - name: Pass BladeLogic Version Check
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'BladeLogic Client Check = Passed' ]"
      when: bl_result.value == bl_version

    - name: Fail if BladeLogic is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'BladeLogic Client Check = Failed' ]"
      when: bl_result.value != bl_version

# Block End
    when:  bl_result.exists == true

# Block Start
  - name: Block for executing command only when bl_result doesnt exists
    block:

    - name: Fail if BladeLogic is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'BladeLogic Client Check = Failed' ]"

# Block End
    when: bl_result.exists == false

# FireEye
# Check FireEye is installed if not a Database server block
  - name: Block for executing command only when not Database
    block:

# Gather FireEye Registry version key value
    - name: Gather FireEye version from Registry
      win_reg_stat:
        path: HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{D82800D5-27A8-4FAC-9564-3F700157BA2F}
        name: DisplayVersion
      register: fireeye_result

# Internal Block
# Block Start
    - name: Block for executing command only when fireeye_result exists
      block:

      - name: Pass FireEye Version Check
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'FireEye Check = Passed' ]"
        when: fireeye_result.value == fireeye_version

      - name: Fail if FireEye is not installed
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'FireEye Check = Failed' ]"
        when: fireeye_result.value != fireeye_version

# Block End
      when: fireeye_result.exists == true

# Internal Block
# Block Start
    - name: Block for executing command only when fireeye_result doesnt exists
      block:

      - name: Fail if FireEye is not installed
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'FireEye Check = Failed' ]"

# Block End
      when: fireeye_result.exists == false

# FireEye Block End
    when:
      - server_role != 'Database'

# NetBackup
# Backup Required Block
  - name: Block for executing command only when backup required
    block:

# Gather NetBackup Registry version key value
    - name: Gather NetBackup version from Registry
      win_reg_stat:
        path: HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\Veritas NetBackup Client
        name: DisplayVersion
      register: netbackup_result

# Internal Block
# Block Start
    - name: Block for executing command only when netbackup_result exists
      block:

      - name: Pass NetBackup Version Check
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'NetBackup Check = Passed' ]"
        when: netbackup_result.value == netbackup_version

      - name: Fail if NetBackup is not installed
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'NetBackup Check = Failed' ]"
        when: netbackup_result.value != netbackup_version

# Block End
      when: netbackup_result.exists == true

# Internal Block
# Block Start
    - name: Block for executing command only when netbackup_result doesnt exists
      block:

      - name: Fail if NetBackup is not installed
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'NetBackup Check = Failed' ]"

# Block End
      when: netbackup_result.exists == false

# Backup Required Block end
    when: 
      - backup_required

#VMWare Tools (Only checks if installed not version)
  - name: Check VMWare Tools Installed
    win_reg_stat:
      path: HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\{F32C4E7B-2BF8-4788-8408-824C6896E1BB}
      name: DisplayVersion
    register: vmtools_result

  - name: Pass VMWare Tools Installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'VMWare Tools Check = Passed' ]"
    when:  vmtools_result.exists == true

  - name: Fail if VMWare Tools is not installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'VMWare Tools Check = Failed' ]"
    when: vmtools_result.exists == false

# McAfee Framework Agent
  - name: Check McAfee Framework Agent Installed Version
    win_reg_stat:
      path: HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\{6256F19B-18EB-4942-8A7C-5A0A9DABFA35}
      name: DisplayVersion
    register: mcafee_result

# Block Start
  - name: Block for executing command only when mcafee_result exists
    block:

    - name: Pass McAfee Framework Agent Version Check
      debug:
        msg: "Pass McAfee Framework Agent required Version is {{ mcafee_version }} installed version is {{ mcafee_result.value }}"
      when: mcafee_result.value == mcafee_version

    - name: Fail if McAfee Framework Agent is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'McAfee Framework Agent Check = Failed' ]"
      when: mcafee_result.value != mcafee_version

# Block End
    when:  mcafee_result.exists == true

# Block Start
  - name: Block for executing command only when mcafee_result doesnt exists
    block:

    - name: Fail if McAfee Framework Agent is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'McAfee Framework Agent Check = Failed' ]"

# Block End
    when: mcafee_result.exists == false

# McAfee Agent (Only checks if installed not version)
  - name: Check McAfee EndPoint Security Platform Installed
    win_reg_stat:
      path: HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\{FF94B30D-A51E-4D68-A353-0667C5655D2E}
      name: DisplayVersion
    register: mcend_result

  - name: Pass McAfee EndPoint Installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'McAfee EndPoint Installed Check = Passed' ]"
    when:  mcend_result.exists == true

  - name: Fail if McAfee EndPoint is not installed
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'McAfee EndPoint Installed Check = Failed' ]"
    when: mcend_result.exists == false

# Tanium
  - name: Check Tanium Installed Version
    win_reg_stat:
      path: HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\Tanium Client
      name: DisplayVersion
    register: tanium_result

# Block Start
  - name: Block for executing command only when tanium_result exists
    block:

    - name: Pass Tanium Version Check
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Tanium Check = Passed' ]"
      when: tanium_result.value == tanium_version

    - name: Fail if Tanium is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Tanium Check = Failed' ]"
      when: tanium_result.value != tanium_version

# Block End
    when:  tanium_result.exists == true

# Block Start
  - name: Block for executing command only when tanium_result doesnt exists
    block:

    - name: Fail if Tanium is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Tanium Check = Failed' ]"

# Block End
    when: tanium_result.exists == false

# .NET Framework
  - name: Check .NET Framework Installed Version
    win_reg_stat:
      path: HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full
      name: Release
    register: dotnet_result

# Block Start
  - name: Block for executing command only when dotnet_result exists
    block:

    - name: Pass .NET Framework Version Check
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ '.NET Framework Check = Passed' ]"
      when: dotnet_result.value == dotnet_version

    - name: Fail if .NET Framework is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ '.NET Framework Check = Failed' ]"
      when: dotnet_result.value != dotnet_version

# Block End
    when:  dotnet_result.exists == true

# Block Start
  - name: Block for executing command only when dotnet_result doesnt exists
    block:

    - name: Fail if .NET Framework is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ '.NET Framework Check = Failed' ]"

# Block End
    when: dotnet_result.exists == false

# Powershell
  - name: Check Powershell Installed Version
    win_reg_stat:
      path: HKLM:\SOFTWARE\Microsoft\PowerShell\3\PowerShellEngine
      name: PowerShellVersion
    register: ps_result

# Block Start
  - name: Block for executing command only when ps_result exists
    block:

    - name: Block for executing command only on 2016 Servers
      block:

      - name: Pass Powershell Version Check
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'PowerShell Check = Passed' ]"
        when: ps_result.value == ps_version_2016

      - name: Fail if Powershell is not installed
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'PowerShell Check = Failed' ]"
        when: ps_result.value != ps_version_2016

# Block End
      when: "'2016' in ansible_os_name"

    - name: Block for executing command only when ps_result exists
      block:

      - name: Pass Powershell Version Check
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'PowerShell Check = Passed' ]"
        when: ps_result.value == ps_version_2012

      - name: Fail if Powershell is not installed
        set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'PowerShell Check = Failed' ]"
        when: ps_result.value != ps_version_2012

# Block End
      when: "'2012' in ansible_os_name"

# Block End
    when:  ps_result.exists == true

# Block Start
  - name: Block for executing command only when ps_result doesnt exists
    block:

    - name: Fail if Powershell is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'PowerShell Check = Failed' ]"

# Block End
    when: ps_result.exists == false

# Splunk Universal Forwarder
  - name: Check Splunk Universal Forwarder Installed Version
    win_reg_stat:
      path: HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\{C05A896E-05F4-49B6-A191-FC29B1362B81}
      name: DisplayVersion
    register: splunk_result

# Block Start
  - name: Block for executing command only when splunk_result exists
    block:

    - name: Pass Splunk Universal Forwarder Version Check
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Splunk Universal Forwarder Check = Passed' ]"
      when: splunk_result.value == splunk_version

    - name: Fail if Splunk Universal Forwarder is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Splunk Universal Forwarder Check = Failed' ]"
      when: splunk_result.value != splunk_version

# Block End
    when:  splunk_result.exists == true

# Block Start
  - name: Block for executing command only when splunk_result doesnt exists
    block:

    - name: Fail if Splunk Universal Forwarder is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Splunk Universal Forwarder Check = Failed' ]"

# Block End
    when: splunk_result.exists == false

# Qualys
  - name: Check Qualys Agent Installed Version
    win_reg_stat:
      path: HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\QualysAgent
      name: DisplayVersion
    register: qualys_result

# Block Start
  - name: Block for executing command only when qualys_result exists
    block:

    - name: Pass Qualys Agent Version Check
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Qualys Agent Check = Passed' ]"
      when: qualys_result.value == qualys_version

    - name: Fail if Qualys Agent is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Qualys Agent Check = Failed' ]"
      when: qualys_result.value != qualys_version

# Block End
    when:  qualys_result.exists == true

# Block Start
  - name: Block for executing command only when qualys_result doesnt exists
    block:

    - name: Fail if Qualys Agent is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Qualys Agent Check = Failed' ]"

# Block End
    when: qualys_result.exists == false

# Dynatrace
  - name: Check Dynatrace Installed Version
    win_reg_stat:
      path: HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{4B646D96-6C5F-4CEC-8815-5BBC0483BD9A}
      name: DisplayVersion
    register: dyn_result

# Block Start
  - name: Block for executing command only when dyn_result exists
    block:

    - name: Pass Dynatrace Agent Version Check
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Dynatrace Agent Check = Passed' ]"
      when: dyn_result.value == dyn_version

    - name: Fail if Dynatrace Agent is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Dynatrace Agent Check = Failed' ]"
      when: dyn_result.value != dyn_version

# Block End
    when:  dyn_result.exists == true

# Block Start
  - name: Block for executing command only when dyn_result doesnt exists
    block:

    - name: Fail if Dynatrace Agent is not installed
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Dynatrace Agent Check = Failed' ]"

# Block End
    when: dyn_result.exists == false

#Check ping to nbu-not-mast.backup.local
# Backup Required Block
  - name: Block for executing command only when backup required
    block:

    - name: Check ping to nbu-not-mast.backup.local
      win_shell: |
        Test-Connection -ComputerName nbu-not-mast.backup.local -Count 5 -Quiet
      register: nbu_ping_result
      check_mode: no

    - name: Pass when nbu-not-mast.backup.local ping test pass
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Ping NBU-NOT-MAST Check = Passed' ]"
      when: "'True' in nbu_ping_result.stdout"

    - name: Fail when nbu-not-mast.backup.local ping test fails
      set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Ping NBU-NOT-MAST Check = Failed' ]"
      when: "'False' in nbu_ping_result.stdout"

# Backup Required Block end
    when: 
      - backup_required

# Check if OS is activated

  - name: Check O/S is activated
    win_shell: |
      Get-CimInstance SoftwareLicensingProduct -Filter "ApplicationID = '55c92734-d682-4d71-983e-d6ec3f16059f'"
      #Get-CimInstance SoftwareLicensingProduct -Filter "ApplicationID = '55c92734-d682-4d71-983e-d6ec3f16059f'" | where licensestatus -eq 1
    register: osactivate_result
    check_mode: no

  - name: Debug stdout_lines
    debug:
      var: osactivate_result

#  - name: Check O/S is activated
#    debug:
#      msg: "Pass O/S is activated"
#    when:
#      - "'ApplicationID                                  : 55c92734-d682-4d71-983e-d6ec3f' in osactivate_result.stdout_lines"
#      - "'LicenseStatus                                  : 1' in osactivate_result.stdout_lines"

#  - name: Check O/S is activated
#    fail:
#      msg: "Fail O/S is not activated"
#    when:
#      - "'ApplicationID                                  : 55c92734-d682-4d71-983e-d6ec3f' not in osactivate_result.stdout_lines"
#      - "'LicenseStatus                                  : 0' in osactivate_result.stdout_lines"

#check that computer name is 15 characters or less

  - name: Check that computer name is 15 characters or less
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Computer name is 15 characters or less = Passed' ]"
    when: ansible_hostname | length < 15
    
  - name: Fail if computer name is greater than 15 characters
    set_fact: Service_Acceptance_Results="{{Service_Acceptance_Results}} + [ 'Computer name is 15 characters or less = Failed' ]"
    when: ansible_hostname | length > 15

#Check that computer is in the correct OU. OU=Windows Server 201x Member Servers,OU=Servers,OU=Systems...
#Check that "Default DSG Member Server 201x Baseline Policy" is being applied.
#Check in Group Policy Log for EventIDs 5310 and 4016 in last 24 hours and filter on relevant messages

# Check SNMP Configuration Settings

#Check that Schannel settings are correct

#Get Culture

#Check TimZone

#Check to see if LGPO has been applied

# Check for a Windows Backup Local

#Check that TADDM / Service Now is not allowed to log on interactively.
#Uses accesschk.exe

#Check that backup connection is set to private and primary is set to DomainAuthenticated

#Ensure that C:\pending_bladelogic_run.txt has been deleted to indicate that this is no longer a "new/build" server

#Check for certificates in the untrusted certificate store

#Check for insecure library loaading

#Check that Users Group has been removed from c:\ibm\itm

#Check that Users Group has been removed from c:\tmp

#Check that Users Group has been removed from c:\temp if it exists

#Test that DEP is set to AlwaysOn

#Check for hardened path entries needed for MS15-011

#Check that Entrust Certificates exist in the correct stores

#For Windows 2012R2 check that RDP cert is using a SHA256RSA signature algorithm
#Not supported on 2012 and the default on Server 2016.

#Windows 2016 Check that Windows Defender Features have been removed amd MultiPath installed

#Check that SMB1 has been removed

#Check that member servers time sync is set to NT5DS and time service is not disabled

#Check if server has backups
# takes a long time if no backup connectivity

#Check that SS000LA exists, is in local administrators and its password expires and is disabled

#Check that DefaultAccount is disabled and its password does not expire
#Check that SS000GU is disabled and its password does not expire

#Check that Windows Media Player is disabled  on 2016

#Check fix in place for FEATURE_ENABLE_PRINT_INFO_DISCLOSURE_FIX (CVE-2017-8529)

#Check that ServicesPipeTimeout is set to 90 seconds on Server 2016

# Display Service_Acceptance_Results Array
  - name: Display Results Array
    debug:
       msg: "{{ Service_Acceptance_Results }}"